* C语言基础 & 算法+数据结构
* os & tcp/ip
	* tcp
	  ![0_131271823564Rx](https://user-images.githubusercontent.com/15995747/145936393-2ef446d4-819f-4e20-9126-f0b4885766f4.gif)
		* 什么是沾包？
		* 为什么挥手要4次？
			关闭连接时，当Server端收到FIN报文时，可能还有报文要送完，只能先回复一个ACK报文。等到所有的报文都发送完了，才能发送FIN报文。
		* 为什么存在timewait阶段？
			网络可能丢包，如果发生丢包，TIME_WAIT阶段可以进行重发。
		* 什么时候会出现大量的time-wait，生产出现大量timewait要怎么处理？
			time-wait是客户端存在的状态，也就是当前服务器创建了大量对其他资源的连接，并短时间内断开链接。
			可以考虑使用长链接或连接池。
	* http
		* http和https的区别？
	* 系统
		* 如何理解用户态和内核态？
			执行的权限不同，用户态代码不能直接操作内存或者其他硬件资源
			如果想要使用硬件资源必须通过系统调用，这就涉及到用户态和内核态的切换-》性能开销
		* 什么是IO多路复用？
			单个process可以监听多个文件描述符
		* epoll 是什么，工作机制是什么？
			epoll是io多路复用的一种底层实现
		* 什么是reactor？
			reactor模式：IO多路复用+处理资源池
			Reactor 三种典型的实现方案：
				单进程/线程（包含reactor）-》redis
					优点：模型简单，没有进程间通信，没有进程竞争
					缺点：无法发挥多核 CPU 的性能；Handler 在处理某个连接上的业务时，整个进程无法处理其他连接的事件
				单Reactor 多线程
					主线程只处理连接新建，请求接收和响应，业务处理交给子线程处理。
					优点：可以利用多核；业务复杂也不影响新建连接的逻辑
					缺点：主线程和子线程需要通信（涉及共享数据的互斥和保护）；如果并发高，主线程也可能成为瓶颈
				主从Reactor 多进程/线程
					主进程reactor只监听服务端口的连接事件，并将新建的连接分配给从进程reactor
					从进程reactor负责连接的接收处理响应
					优点：充分使用了多核；分散了请求；父子进程间的通信简单
					缺点：-
		* 如何理解进程、线程、协程？
			协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程
	* linux
		* linux常用命令
		* 从日志里过滤ip排行前10

* golang / php
	* php&fpm
		* php5和php7的区别
		* fpm的运行（过程）机制（zendVm、sapi）
			扩展是什么时候加载的
			扩展是怎么跟php交互的
			opcache是什么 有什么好处 原理
			请求的生命周期
		* gc是怎么实现的
		* cgi和fastcgi的区别
		* 什么是写时复制？为什么？
		* 常用框架 
			laravel(DI ioc)、TP
		* 自己实现框架，要考虑哪些因素
		* 具体函数的掌握：isset和isempty的区别
	* go（重点）
		* golang和php的区别？或golang更优秀的地方
		* go的map、数组的底层实现
		* context、sync的区别
		* gpm模型（go为什么这么快）
			关键是减少了内核级别上下文切换
		* go的gc
		* gRPC 
			gRPC是一个高性能、开源、通用的RPC框架，基于HTTP2协议标准设计开发；默认采用ProtoBuf数据序列化协议；支持多种开发语言，自动生成功能库

* OOp&设计模式
* 微服务+DDD+敏捷、 分布式相关理论
	* 微服务
		* 微服务的优劣
			* 代码精简
			* 各个服务可以采用异构的技术
			* 服务职责明确
			* 容易伸缩

			* 定位故障困难
			* 稳定性下降，容易雪崩
			* 服务数量非常多，部署、管理的工作量大
		* 基础组件
			* 服务注册与发现（服务路由）
				Zookeeper、Eureka、Consul、Etcd等
			* 服务容错
				熔断、降级、限流
			* api网关
				外部系统的访问操作
				1 功能封装？？
				2 接入鉴权、权限控制、传输加密、请求路由、流量控制等功能
			* 配置中心
				解决什么问题？
			* 服务监控&预警
				Prometheus // 用于收集和存储数据
				Grafana //数据可视化+预警 
					支持的数据源更多
					展示效果更美观
					支持权限管理
			* 日志分析
				ELK日志分析组件
					filebeat、Logstash 数据收集处理引擎
					elasticsearch 分布式搜索引擎（存储）
					Kibana 可视化化平台
						只能对接 ElasticSearch
						展示log的明细，且可以写条件搜索
			* 服务跟踪
				zipkin
		* 微服务平滑重启如何实现
		* 扩容要注意什么

* 基础组件
	* nginx 为什么运行的这么快
		主要是使用了io多路复用（非标准的多reactor多进程）
		master监听服务端口并fork子进程
		新的连接请求到来时，worker竞争锁，获取到锁的进程和客户端建立连接并将连接注册到epoll

		连接数=进出数*每个进程数
		反向代理连接数=进出数*每个进程数/2

	* redis
		* 对redisobject的了解
		* redis怎么持久化（rdb aof），分别有什么优劣
		* save/bgsave区别
		* redis什么时候会清理失效数据（定期&访问）
		* 淘汰机制有几种，使用的是那种，为什么？
		* 有续集的底层实现
			压缩列表
			hash+跳表
			跳表的实现
				查找 从最高层开始逐层往下（logN）
				插入 初始化节点，随机层数，找到插入点，找到小于当前节点分值的临近层数，更新指针
		* redis踩过哪些坑
		* 如何提高redis 的命中率
		* 大key/热key怎么处理（为什么要避免大key操作）
		* 缓存穿透、缓存击穿、雪崩 缓存集中失效 怎么处理
		* 怎么保证高可用
			哨兵模式-原理

	* redis-cluster

	* mysql
		* myisam & innodb
			myisam：使用b+树，非聚簇索引
			innodb：使用b+树，聚簇索引；支持事务、外键、行锁
		* 为什么使用B+数（avl bTree 和 b+tree 为什么mysql使用b+tree）
			b+树是多路自平衡树，查询的时间复杂度为log(n)。
			b+树非叶子结点仅存储指针信息，相对B树，树高更低，io操作更少
		* 如何优化
			使用explain命令，看下rows、索引情况，如果表记录数超过千万要考虑分表；否则看下有没有使用到索引
			除了explain呢？
		* 加索引有什么考虑
			出现在where条件中的，字段的选择性较大的，最左原则
			*为什么用自增列作为主键
				非单调的主键会造成在插入新记录时频繁的分裂调整，造成额外的io并产生数据碎片
		* 事务
			* 事务如何保证原子性
			* mysql有几种日志
			* 隔离级别，实现
				未提交读：不加锁、不用mvcc、直接当前读
				提交读：使用mvcc、写加行锁
				可重复读：使用mvcc、写加间隙锁
				序列化：读加读锁、写加写锁
			* 锁
				innodb的锁有哪些
				什么情况会产生死锁？怎么处理
			* mvcc
				如何实现
				作用：一致性读 & 事务回滚
		* 分库分表（主要问的水平分表）
			* 什么量级的时候分库分表
				达到千万级别就可以考虑了。
				结合B+树，已知一页大小为16K，假设一条记录大小为1K，一页能存储16条记录
				假设索引类型为bigint（8bytes）指针大小为6bytes，内节点能存储的指针数16K/14=1000
				高度为3的树能存储的数据为：1000*1000*16 = 1600W
			* 路由算法（分表机制是什么）
				范围路由：平滑地扩充新的表；缺点是分布不均匀（具体看业务）
				hash路由：数据分布均匀；缺点是扩充困难（需要数据迁移）-》一致性hash：降低扩展的复杂度
			* 其他
				执行count()、order by等变得复杂
		* 主从
			如何实现：主机开启binlog，从机同步主机的binlog到本地的relaylog，并重放
			bilog里面有什么东西？？
			有啥问题：主从延迟，业务分流强需求的读写都走主库；从库没读到回主表再读（增加主库压力）；增加缓存

	* rabbitmq
		* 特性
			消息路由灵活
			消息生存时间
			延迟队列
			死信队列
			简单的消费者实现
		* 解决什么场景：解藕 异步 消峰
		* 消息的顺序性
		* 如何让保证消息的可靠性
			发送 confirm机制
			mq本身 队列&消息持久化
			消费 ack机制
		* 如何让保证消息不回被重复消费
		* 消息积压怎么处理
			临时扩容消费者
		* 高可用
			镜像集群模式
	* kafka
		* 特性
			分区消息有序
			消息可以在一定时间内留存
			吞吐量大

* 具体业务
	* 2345-升级平台重构
		重构的时候考虑哪些因素
		为什么重构 怎么重构
			1 梳理业务逻辑，产出相关文档
			2 优化代码，原先有大量特殊逻辑，添加新功能就往上叠加，现在在梳理业务逻辑后进行移除
			3 为golang积累经验

		重构之后有哪些变化
		重构只是将php翻译过来吗？有哪些优化处理
		cpu为什么下降，做了哪些优化
		上线方案是什么样的？ 

	* 2345-用户中心-引入消息队列
		2345优化日志统计 怎么去做的
		没引入消息队列之前，同步返回，客户端可以感知错误，引入消息队列后，怎么处理这个问题？
			本来这些接口的返回就不影响返回

		200ms不是很快，为什么不进一步优化？


	* 虎扑-重构
		为什么使用swoole，要解决什么问题
		phpfpm与swoole机制的差异

	* 虎扑-redis-cluster
		为什么使用？要解决什么问题

	* 2345
		* 日志机制

	* 虎扑
		* 被人刷过帖子吗？如何处理

* 其他
	** 哪家可以聊下技术栈和技术氛围（哪个项目问题最多）｜介绍做的比较好的项目
	* 做了什么、怎么做的、为什么这么做（要解决什么问题）、做了之后的效果
	* 架构什么样的（物理｜逻辑的）
	* 有哪些代码优化的经验
	* 项目中有哪些架构的设计

	* 怎么看待多级缓存（缓存的使用）
	* 缓存更新方式
	* 线上接口慢或者报错 怎么定位问题
	* 设计秒杀系统
	* 浏览器输入url到页面呈现，会发生哪些事情
	* 监控系统原理 普罗米修斯
	* 接口如何保证幂等性

	* id发号器
		直接用一张临时表使用递增字段，定期删除（或者用redis）
	* 非微服务情况下如何保证动态扩增容
	* 分表和rabbitmq都用来处理写压力 分别是什么原理，各有什么优劣
	* 异地多活需要考虑哪些问题
	* 复杂系统数据一致性问题

	* 有带过团队吗
	* 跨部门沟通有什么问题
	* 团队分享	
	* 为什么离职
















